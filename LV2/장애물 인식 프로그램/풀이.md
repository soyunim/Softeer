## 문제 이해
- 0이 아닌 숫자는 장애물
- 장애물 블록수 출력
- 장애물 블록 당 장애물 수 출력하되, 장애물 수가 가장 적은 순으로 출력

## 풀이
- dfs사용
1. 지도 내용을 graph로 입력받기
2. 이중 for문 사용하여 dfs(i,j)가 True이면 총 블록수(answer) +1해주기
3. dfs(i,j) 함수에서 graph[i][j]가 1이면 장애물이 맞으므로 해당 블록의 장애물수(cnt) +1해주기
4. graph[i][j]와 연결된 부분들도 장애물인지 확인하기 위해 dfs함수를 상하좌우로 실행해주기
5. 해당 블록에 대한 dfs함수가 종료되면 해당 블록의 장애물수를 result에 저장해주기
6. 다른 블록이 있는지 확인해야하기 때문에 cnt 저장해주는 값 초기화, (2~6)반복.
7. 이중 for문이 종료되면 총 블록수(answer) 먼저 출력
8. 블록 당 장애물수(result)를 오름차순으로 sort해준 뒤 순서대로 출력